# 快速排序

> 转载自：极客时间 数据结构与算法专栏

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。

![](../../.gitbook/assets/image%20%2860%29.png)

## **算法描述**

1. 从数列中挑出一个元素，称为 "基准"（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

## **动图演示**

![](../../.gitbook/assets/quick-sort.gif)

## 代码实现

```go
func QuickSort(arr []int, low, high int) {
	var temp int
	i := low
	j := high
	if low < high {
		temp = arr[low]
		//下面循环完成一次排序，即将数组中小于temp的关键字放在左边，大于temp的关键字放在右边
		for i < j {
			for j > i && arr[j] >= temp {
				j = j - 1
			}
			if i < j {
				arr[i] = arr[j]
				i = i + 1
			}
			for i < j && arr[i] < temp {
				i = i + 1
			}
			if i < j {
				arr[j] = arr[i]
				j = j - 1
			}
		}
		arr[i] = temp
		QuickSort(arr, low, i-1)
		QuickSort(arr, i+1, high)
	}
}
```

## **时间复杂度分析**

如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O\(nlogn\)。

```go
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
```

但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。

举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O\(nlogn\) 退化成了 $$O(n^2)$$。

我们刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？

我们假设每次分区操作都将区间分成大小为 9:1 的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：

```go
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。

T(n) = T(n/10) + T(9*n/10) + n； n>1
```

这个公式的递推求解的过程非常复杂，虽然可以求解，但不推荐用这种方法。T\(n\) 在大部分情况下的时间复杂度都可以做到 O\(nlogn\)，只有在极端情况下，才会退化到 O\(n2\)。

