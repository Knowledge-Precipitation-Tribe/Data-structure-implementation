# 冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

## **算法描述**

* 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
* 针对所有的元素重复以上的步骤，除了最后一个；
* 重复步骤1~3，直到排序完成。

我用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：

![](../../.gitbook/assets/image%20%2869%29.png)

可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

![](../../.gitbook/assets/image%20%2865%29.png)

实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。

![](../../.gitbook/assets/image%20%2861%29.png)

## **动图演示**

![](../../.gitbook/assets/bubble-sort.gif)

## 代码实现

```go
func BubbleSort(arr []int) []int {
	length := len(arr)
	for i := 0; i< length - 1; i++{
		for j := 0; j < length - i - 1; j++{
			if arr[j] > arr[j + 1]{
				temp := arr[j + 1]
				arr[j + 1] = arr[j]
				arr[j] = temp
			}
		}
	}
	return arr
}
```

## 时间复杂度分析

最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O\(n\)。

而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $$O(n^2)$$。

![](../../.gitbook/assets/image%20%2866%29.png)

对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“有序度”和“逆序度”这两个概念来进行分析。

有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

```go
有序元素对：a[i] <= a[j], 如果i < j。
```

![](../../.gitbook/assets/image%20%2859%29.png)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n\*\(n-1\)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。

逆序度的定义正好跟有序度相反（默认从小到大为有序）。

```go
逆序元素对：a[i] > a[j], 如果i < j。
```

关于这三个概念，我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 \(4，5\) \(4，6\)\(5，6\)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n\*\(n-1\)/2=15。

![](../../.gitbook/assets/image%20%2864%29.png)

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n\*\(n-1\)/2–初始有序度。此例中就是 15–3=12，要进行 12 次交换操作。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n_\(n-1\)/2 次交换。最好情况下，初始状态的有序度是 n_\(n-1\)/2，就不需要进行交换。我们可以取个中间值 n\*\(n-1\)/4，来表示初始有序度既不是很高也不是很低的平均情况。

换句话说，平均情况下，需要 n\*\(n-1\)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $$O(n^2)$$，所以平均情况下的时间复杂度就是 $$O(n^2)$$。

